# Руководство по работе со стилями ProStore

Данный документ описывает организацию рабочего процесса
 по разработке CSS для тем оформления интернет-магазинов на платформе ProStore.
 
Жизненное наблюдение: проекты без организации достигают некоторой критической точки,
после которой наступает полный хаос — даже автор не может вспомнить, за что отвечает
то или иное правило, и используется ли оно вообще. Часто можно видеть,
как стили, которые выглядели опрятно в самом начале, обрасли четырехэтажными
селекторами с `!important` возле каждого свойства.

Поддерживать такие проекты на плаву становится чрезвычайно тяжело, не говоря уже
о развитии и доработках. Поэтому важно выработать подход, позволяющий эффективно
создавать, изменять, развивать и поддерживать CSS и HTML.

При разработке правил мы руководствуемся популярными методологиями:
[БЭМ](https://ru.bem.info/), [SMACSS](https://smacss.com/), [MVCSS](http://mvcss.io/).
По ряду причин ни одна из методологий не решает всех проблем, одновременно являясь
простой и совместимой с популярными CSS-фреймворками ([Bootstrap](http://getbootstrap.com/),
[Foundation](http://foundation.zurb.com/) и т.д.). Предлагаемая нами методология
является существенным упрощением MVCSS с заимствованием некоторых идей из SMACSS.

## Сборка и препроцессоры

Сборка проекта осуществляется с помощью модуля
[ProStore Theme API](http://github.com/prstr/theme-api),
который поддерживает три наиболее популярных препроцессора CSS:

  * [Less](http://lesscss.org/)
  * [Sass](http://sass-lang.com/)
  * [Stylus](https://learnboost.github.io/stylus/)

А также постпроцессор [PostCSS](https://github.com/postcss/postcss) с плагином
[Autoprefixer](https://github.com/postcss/autoprefixer).

Ограничение в выборе инструментов сборки с одной стороны обусловлено необходимостью
предоставления пользователям инструмента кастомизации темы через веб-интерфейс
(с помощью переменных). С другой стороны, это формирует стандартный рабочий процесс
по разработке модульных и масштабируемых стилей, не привязывая разработчика или 
дизайнера к какому-то одному препроцессору.

Базовая тема написана на Stylus, но в целях переносимости между препроцессорами
выбран синтаксис, максимально близкий к CSS (мы пишем фигурные скобки и точки
с запятой).

## Категоризация CSS правил
 
Все правила разделяются на следующие категории.

  * **Ядро** содержит:
  
    * `reset` — стили, сбрасывающие правила, применяемые браузером по умолчанию
    
    * `fonts` — директивы `@font-face` для веб-шрифтов
    
    * `variables` — переменные для расчета цветовой схемы, размеров и прочих
      формальных характеристик темы
      
    * `mixins` — миксины, используемые в других правилах
    
    * `base` — стилизация базовых семантических тэгов
      (`html`, `body`, `p`, `ul`, `ol` и т.д.)
      
    * `helpers` — вспомогательные стили, используемые для быстрого задания
      какого-либо свойства без создания отдельного компонента для этой цели.
    
  * **Компоненты** — автономные и переносимые модули, формирующие основу UI
    (например, сетки, кнопки, панели и т.д.).
   
  * **Структуры** — более крупные модули, связанные с предметной областью приложения
    (например, витрина продукта, рабочая область раздела администрирования и т.д.)
    
## Соглашения

* Наиболее общие селекторы (тэги, `*`) допустимы в `reset`, `base` и,
  в качестве исключения, в компоненте `input`.

* Использование селекторов по ID (наподобие `#id`) не допускается.

* Для применения стилей к компонентам и структурам используются селекторы по классам
  (наподобие `.class`).
  
* Компоненты могут содержать подэлементы. Например, панель кнопок `.toolbar`
  может содержать группу кнопок `.toolbar-group`. 
  
  Подэлементы стилизуются с помощью простого селектора по классу, использовать
  «тяжелые» селекторы _не рекомендуется_ во избежание проблем с переопределением
  (т.е. `.toolbar-group { ... }` — правильно, `.toolbar .toolbar-group` — неправильно).
  
* Многие компоненты поддерживают модификаторы. Например, компонент `.btn` задает
  основные свойства кнопки (размер, блочную модель и т.д.), а модификатор
  `.btn-primary` задает цвет кнопки. 
  
  Для модификаторов также используются простые селекторы по классу
  (т.е. `.btn-primary { ... }` — правильно, `.btn.btn-primary` — неправильно).
  
* Названия классов модификаторов и подэлементы начинаются с названия компонента
  и отделяются от него через дефис (т.е. `.<компонент>-<элемент>-<модификатор>`).
  В отличие от БЭМ и MVCSS мы не используем различные разделители, чтобы подчеркнуть
  разницу, но требуем, чтобы модификатор всегда следовал последним. Это соглашение
  более адаптировано к CSS-фреймворкам (Bootstrap, Foundation, Flat UI, Rubix и т.д.).
  
* Слова в названиях компонентов и структур разделяются дефисом.
  
* Каждый компонент и каждая структура помещаются в отдельный файл с соответствующим
  названием. В начале файла рекомендуется приводить короткую документацию, включающую:
  
  * название компонента/структуры,
  * краткое описание и область применения,
  * схему использования — псевдокод, позволяющий понять, какие модификаторы и
    подэлементы поддерживает компонент.
  
* В некоторых случаях допустимо использование более тяжелых селекторов, чем
  селектор по классу:
  
    * псевдоселекторы и псевдоэлементы, которые не существуют отдельно от
      других селекторов;
      
    * класс-состояние (пр. `active`) всегда используется вместе с другим селектором,
      к которому применяется (например, `.btn.active`); такие классы документируются
      отдельно в конце данного документа;
      
    * контекстные компоненты, задающие особое поведение компонентов внутри себя
      (пр. `.btn-group`, `.layout-fixed`, `.grid-gutters`, `.inline-grid` и т.д.);
      использование таких селекторов должно быть документировано с помощью схемы.
      
* Свойства в рамках правила располагаются в логическом порядке:
 
  * миксины,
  * `content` в псевдоэлементах,
  * позиционирование (`position`, `top`, ...),
  * блочная модель (`display`, `overflow`, `float`, `flex`, ...),
  * размеры (`width`, `height`, `padding`, `border-width`, ...),
  * цвета (`border-color`, `color`, `background`, `box-shadow`, ...),
  * текст (`font`, `line-height`, `text-decoration`, `text-transform`, ...)
  * визуальные эффекты (`transform`, `opacity`, `transition`, ...)
  
  Правило нестрогое, допускается переставлять группы местами, если так понятнее.
  К примеру, если имеет место анимация при наличии какого-либо класса, то
  `transition` и свойства, перечисленные в нем, могут идти в самом конце, а следом
  может идти класс, модифицирующий свойства.
  
## Схема использования

Схемы использования позволяют понять, как использовать тот или иной компонент:
какие модификаторы, подэлементы и состояния он поддерживает.
 
При составлении схемы использования удобно использовать компактный и емкий синтаксис,
например:

```
.toolbar  // селектор указывает на элемент
  // два пробела показывают на вложенность
  .toolbar-group<.toolbar-group-left | .toolbar-group-right>
    // угловые скобки означают что-то < обязательное >, `|` == `или` 
    [.toolbar-title] // квадратные скобки означают [ необязательное ]
    [.btn-group | .inline-grid]
      .btn {...} // в фигурных можно написать многоточие или перечислить примеры
```

См. компоненты, чтобы увидеть больше схем. 
      
## Классы-состояния

  * `.active` — `.btn`
  * `.ng-dirty`, `.ng-pristine`, `.ng-invalid` — `input`, `select`
